# Photoshop App ロードマップ

## ビジョン

**「AIに指示するだけで、プロ品質のサムネイルが自動生成されるエディタ」**

Photoshopは強力だがAIフレンドリーではない。本アプリは最初からAIとの協業を前提に設計し、
YouTube/商品サムネイルの制作を完全自動化する。

---

## 現状の資産（既に構築済み）

| カテゴリ | 実装済み内容 |
|:---------|:------------|
| レイヤーシステム | ラスター・テキスト・グループの3種。ツリー構造、マスク、16ブレンドモード |
| レイヤーエフェクト | 全8種（ストローク、ドロップシャドウ、外側グロー、内側シャドウ、内側グロー、カラーオーバーレイ、グラデーションオーバーレイ、ベベル&エンボス） |
| テキストレイヤー | フォント、サイズ、色、太字/斜体、揃え、縦書き、下線、打消し線、行間、字間 |
| レンダリング | Canvas 2D（フル機能）+ WebGL 2（GPU高速化、エフェクト一部） |
| AI切り抜き | Mobile SAM（ONNX）でポイントプロンプト + マスク調整 |
| ファイルI/O | PSD読み書き、ABRブラシ読込、ASLスタイル読込 |
| ツール群 | ブラシ(4種)、選択(矩形/楕円/自動/色域)、グラデーション、塗りつぶし、図形、スタンプ、覆い焼き/焼き込み |
| フィルタ | 15種（明るさ/コントラスト/色相彩度/レベル/トーンカーブ/カラーバランス/ぼかし等） |
| UI | レイヤーパネル、レイヤースタイルダイアログ(8タブ)、テキストプロパティ、アセットブラウザ、ヒストリー、i18n(日英) |

---

## フェーズ構成

```
Phase 0: 基盤品質強化（土台固め）
    ↓
Phase 1: サムネイル制作の完全手動フロー確立
    ↓
Phase 2: AI操作レイヤーの構築
    ↓
Phase 3: AI自動サムネイル生成
    ↓
Phase 4: 参照画像からの再現生成
```

---

## Phase 0: 基盤品質強化（土台固め）

> **目的**: 現在のコードを「サムネイル制作に耐えるレベル」まで安定させる

### 0-1. テキストレンダリング品質の向上
- **フォントシステムの強化**
  - 現状: ハードコード7フォント（Arial, Helvetica, Times New Roman等）
  - 目標: システムフォント列挙 + Google Fonts + カスタムフォント(.ttf/.otf)読込
  - サムネイルではフォント選択が命。Impact/Noto Sans JP以外にも「けいふぉんと」「源ノ角ゴシック」等の日本語フォントが必須
- **テキスト描画のアンチエイリアス・サブピクセル品質確認**
  - Canvas 2D の `ctx.font` ベース描画の限界調査
  - 必要に応じてOpenType.jsやHarfBuzzWASMでのグリフレベル描画を検討

### 0-2. レイヤーエフェクトの実用品質検証
- 全8エフェクトの組み合わせテスト（特にテキストレイヤーへの適用）
- Photoshopとの出力比較 → 差異が大きい箇所の修正
- 特にサムネで多用される: **ストローク（縁取り）**、**ドロップシャドウ**、**外側グロー**

### 0-3. エクスポート品質の確認
- PNG/JPGエクスポートで全エフェクトが正確に出力されることの検証
- 1280x720 (YouTube標準サムネサイズ) での出力テスト

### 0-4. パフォーマンス基準値の設定
- 1280x720キャンバス、10レイヤー、各レイヤーにエフェクト2-3個 → 描画が1秒以内

---

## Phase 1: サムネイル手動制作の完璧なフロー

> **目的**: 「手動でやれば完璧なサムネイルが作れる」状態を達成する
> これがPhase 2以降のAI自動化のゴールドスタンダードになる

### 1-1. サムネイルテンプレートシステム
- **プリセットキャンバスサイズ**: YouTube (1280x720), Twitter (1200x675), Instagram (1080x1080) 等
- **テンプレート保存/読込**: レイヤー構成・エフェクト設定を丸ごとテンプレートとして保存
- 形式: `.psxp`（既にtypes定義あり）を実装する

### 1-2. テキストスタイルプリセット
- サムネでよく使うテキストスタイル（フォント+エフェクトのセット）をプリセット化
  - 例: 「YouTuber定番」（白文字＋黒縁取り＋ドロップシャドウ）
  - 例: 「インパクト」（赤文字＋白縁取り＋黒外側グロー）
  - 例: 「エレガント」（金文字＋ベベルエンボス＋ドロップシャドウ）
- ASLインポートは既にあるので、Photoshopの人気スタイルをそのまま取り込み可能
- ワンクリックでテキストレイヤーにスタイル一括適用

### 1-3. 背景・雰囲気ツールの強化
- **グラデーション背景プリセット**: サムネでよく使う配色パターン
- **パターンオーバーレイ**: ドット、ストライプ、集中線など（サムネ頻出パターン）
- **図形のスタイル付き配置**: 角丸矩形にエフェクト適用（吹き出し、タイトルバー等）
- **画像の配置**: 外部画像(PNG/JPG)をレイヤーとしてドラッグ&ドロップ配置

### 1-4. 枠線・装飾エフェクト
- **キャンバス全体への枠線**: サムネの外枠（太さ、色、内側/外側）
- **集中線エフェクト**: 中心から放射状に線を出す（マンガ風）
- **グラデーションマスク**: 画像の一部をフェードアウト（テキストエリア確保用）

### 1-5. レイヤー操作の拡充
- **レイヤーのロック実装**: locked プロパティのUI反映（背景レイヤー保護等）
- **レイヤーのクリッピングマスク**: 下のレイヤーの形に切り抜く
- **スマートオブジェクト（簡易版）**: 非破壊でのリサイズ・フィルタ適用

---

## Phase 2: AI操作レイヤーの構築

> **目的**: AIがエディタを「手」として使えるAPIを構築する
> ここが本プロジェクトの核心

### 2-1. エディタ操作API（Editor Action API）
AIがエディタの全機能をプログラマティックに操作するためのAPI層。

```typescript
// 例: AIが実行するアクション
interface EditorAction {
  type: 'createTextLayer' | 'setLayerEffect' | 'setPosition' |
        'setFont' | 'addImage' | 'applyFilter' | 'setBackground' | ...;
  params: Record<string, unknown>;
}

// AIからのアクション列を受け取って逐次実行
function executeActions(actions: EditorAction[]): void;
```

- Zustandストアの全アクションをEditorAction経由で呼び出し可能にする
- 各アクションはUndo対応（既存のCommand パターンに統合）
- アクション実行のバリデーション（不正なフォント名、範囲外の座標等のガード）

### 2-2. キャンバス状態のAI可読スナップショット
AIが現在のキャンバス状態を「読める」形式で取得する仕組み。

```typescript
interface CanvasSnapshot {
  canvas: { width: number; height: number; dpi: number };
  layers: LayerSnapshot[];  // 各レイヤーの種類・位置・サイズ・エフェクト
  thumbnail: string;        // Base64エンコードの全体サムネイル
}
```

- AIが「今何がキャンバスにあるか」を把握して次のアクションを決定するために必要
- レンダリング結果の画像（低解像度）も含めて、視覚的なフィードバックを提供

### 2-3. MCP (Model Context Protocol) サーバー化
Claude等のAIモデルがMCP経由でエディタを直接操作できるようにする。

```
AI (Claude) ──MCP──> Photoshop App MCP Server ──> Editor Action API ──> Zustand Store
```

- MCPサーバーをElectronメインプロセス内に立てる（またはサイドカーとして起動）
- ツール定義:
  - `create_text_layer(text, font, size, color, position)`
  - `apply_layer_style(layerId, styleName | effectsConfig)`
  - `set_background(type, params)`
  - `get_canvas_snapshot()`
  - `export_image(format, quality)`
  - etc.
- これにより、Claude Codeから直接サムネイルを作成可能になる

### 2-4. スタイル分析エンジン
レイヤーエフェクトのパラメータを「言語的に」記述・逆変換する仕組み。

```
「白文字に黒の太い縁取り」
  ↔ { type: 'stroke', color: '#000000', size: 4, position: 'outside' }
    + { fontColor: '#FFFFFF' }

「ゴールドのメタリック感」
  ↔ { type: 'gradient-overlay', ... } + { type: 'bevel-emboss', ... }
```

- 自然言語 → エフェクトパラメータ変換（AIのプロンプトとして利用）
- エフェクトパラメータ → 自然言語記述（AIがスナップショットを読むときに利用）

---

## Phase 3: AI自動サムネイル生成

> **目的**: 「こういう雰囲気のサムネを作って」で完成品が出る

### 3-1. サムネイル設計AI（Thumbnail Architect）
ユーザーの指示からサムネイルの「設計図」を生成するAIワークフロー。

```
Input:  「衝撃的なニュース系のサムネ。タイトル: "AIが弁護士を超えた日"」
Output: サムネイル設計図（JSON）
  - 背景: 暗い青グラデーション + 集中線
  - メインテキスト: "AIが弁護士を超えた日" / Impact / 72px / 白 / 黒縁取り4px+赤外側グロー
  - サブテキスト: "2026年最新レポート" / Noto Sans JP / 24px / 黄色 / 黒縁取り2px
  - レイアウト: メインテキスト中央やや上、サブテキスト下部
```

- カテゴリ別のサムネイルデザインパターンDB（ニュース系、How-To系、Vlog系、商品紹介系等）
- 色彩心理学・視線誘導のルールをプロンプトに組み込み

### 3-2. フォント自動選択AI
テキスト内容と雰囲気からフォントを自動選択。

- フォントカタログ（インストール済みフォント一覧 + メタデータ）
- フォント属性タグ: 「力強い」「エレガント」「カジュアル」「ポップ」「フォーマル」等
- AIがタグとテキスト内容を照合して最適フォントを選択

### 3-3. エンドツーエンド自動生成パイプライン
設計図→Editor Action API→完成画像の一気通貫パイプライン。

```
ユーザー指示 → Thumbnail Architect → 設計図JSON → Action列変換 → Editor Action API → レンダリング → PNG出力
```

- 生成後にユーザーがUI上で微調整可能（AIが作ったレイヤーは普通に編集できる）
- 「もう少し派手に」「色味を変えて」等の反復指示にも対応

### 3-4. スタイルライブラリの拡充
- 人気YouTuberのサムネイルスタイルを分析→プリセット化
- ジャンル別デフォルトスタイル（ゲーム実況、料理、ビジネス、テック等）
- ASLファイルからのインポート → AIが使えるスタイルカタログに登録

---

## Phase 4: 参照画像からの再現生成

> **目的**: 「この画像と同じようなサムネを作って」で再現できる

### 4-1. サムネイル解析AI（Thumbnail Analyzer）
参照画像を分析して構造を抽出する。

- **レイアウト検出**: テキスト位置、画像位置、背景領域の分割
- **テキスト認識（OCR）**: テキスト内容の読み取り
- **フォント推定**: 使われているフォントの推定（Google Font APIやフォントマッチングモデル）
- **カラーパレット抽出**: 主要色・アクセント色の抽出
- **エフェクト推定**: 縁取りの色と太さ、シャドウの方向と強さ、グロー等の推定

### 4-2. スタイル転写エンジン
分析結果を設計図に変換し、新しいテキスト/画像で再現する。

```
Input:  参照画像 + 新しいタイトルテキスト
Process: 参照画像分析 → 設計図抽出 → テキスト差し替え → Action列生成
Output: 参照画像と同じ「雰囲気」で新しい内容のサムネイル
```

### 4-3. AI画像生成との統合
- **背景生成**: ComfyUI/Stable Diffusion APIと連携して、テーマに合った背景画像を自動生成
- **人物切り抜き合成**: SAM（既存）で人物を切り抜き → 背景と合成
- **ロゴ・アイコン生成**: 簡易なグラフィック要素の自動生成

### 4-4. バッチ生成・A/Bテスト
- 同じ内容で複数バリエーションのサムネイルを一括生成
- 「ニュース風」「ポップ風」「ミニマル風」等のスタイルバリエーション
- ユーザーが気に入ったものを選択 → スタイル学習に反映

---

## 実装優先度マトリクス

```
重要度高 ─────────────────────────────────────────── 重要度低
    │                                                    │
緊  │ [0-1] フォントシステム    [0-2] エフェクト品質検証 │
急  │ [1-2] テキストスタイル    [1-3] 背景ツール         │
度  │       プリセット                                   │
高  │ [2-1] Editor Action API                            │
    │ [2-3] MCPサーバー化                                │
    │                                                    │
    │ [1-1] テンプレート        [0-3] エクスポート検証   │
    │ [2-2] AIスナップショット  [1-4] 枠線装飾           │
    │ [3-1] サムネ設計AI        [1-5] レイヤー操作拡充   │
    │ [2-4] スタイル分析                                 │
緊  │                                                    │
急  │ [3-2] フォント自動選択    [0-4] パフォーマンス     │
度  │ [3-3] E2Eパイプライン     [4-3] 画像生成統合       │
低  │ [4-1] サムネ解析AI        [4-4] バッチ生成         │
    │ [4-2] スタイル転写                                 │
    └────────────────────────────────────────────────────┘
```

---

## 推奨着手順序

### すぐやる（Phase 0 + Phase 1の核）
1. **0-1: フォントシステム** — サムネの品質はフォントで決まる
2. **0-2: エフェクト品質検証** — テキスト+エフェクトの実用レベル確認
3. **1-2: テキストスタイルプリセット** — よく使う組み合わせをワンクリック適用

### 次にやる（Phase 1の残り + Phase 2の核）
4. **1-3: 背景・雰囲気ツール** — サムネの土台を素早く作れるように
5. **2-1: Editor Action API** — AIが操作する入り口を作る（Phase 3の前提）
6. **2-2: AIスナップショット** — AIが現状を把握できるようにする

### その後（Phase 2完成 + Phase 3開始）
7. **2-3: MCPサーバー化** — Claude Codeから直接操作可能に
8. **3-1: サムネイル設計AI** — 「こういう雰囲気で」に応える
9. **3-3: E2Eパイプライン** — 指示→完成品の一気通貫

### 最後（Phase 4）
10. **4-1: サムネイル解析AI** — 参照画像の構造分析
11. **4-2: スタイル転写** — 分析結果で再現

---

## 技術的な注意点

### フォントに関して
- Electronではメインプロセスから `systemPreferences` や OS APIでシステムフォント一覧を取得可能
- Google Fontsは API で検索→ダウンロード→`FontFace` APIでランタイムロード
- カスタムフォントは `.ttf/.otf` をドラッグ&ドロップ→ `FontFace` で登録
- OpenType.jsを使えばグリフレベルの制御が可能（将来的にパス変換→SVG→ラスタライズ）

### MCP統合に関して
- Electron メインプロセスにMCPサーバーをホスト
- stdio transport で Claude Code から接続
- `settings.json` に追加するだけでClaude Codeが認識
- Editor Action API をMCPツール定義にそのままマッピング

### エフェクト品質に関して
- Canvas 2D のブラー（ぼかし）はブラウザ依存で品質にばらつきあり
- 高品質なGaussian blurが必要な場合はピクセル単位のソフトウェア実装を検討
- WebGL側のエフェクト対応はPhase 0では後回し（Canvas 2Dで十分な品質が出れば）

### AI推論に関して
- サムネイル設計AIはClaude API（外部）を前提。ローカル推論は不要
- フォント推定やOCRは既存のクラウドAPI（Google Vision等）も候補
- 重い処理はElectronメインプロセスのWorkerスレッドで非同期実行
