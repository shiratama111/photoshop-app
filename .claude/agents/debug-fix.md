# photoshop-app デバッグ エージェントチーム

複数フェーズの長期的アプローチで、photoshop-app のバグを体系的に調査・修正するチーム。
先に調査・仮説立案を十分に行い、検証ループを回しながら段階的に修正を進める。

## 設計思想

- **スカウト→仮説→並列検証→修正→回帰テスト** の構造化デバッグ
- 1回の長大セッションではなく、フェーズごとに区切り（Ralph Wiggumパターン）
- 各フェーズで成果物を `debug-log.md` に蓄積し、次フェーズに引き継ぐ
- 検証ループ（テスト実行→失敗→修正→再テスト）を重視
- 3回同じアプローチで失敗したらフレームを変える

## プロジェクト固有コンテキスト

### 技術スタック
- **Electron** (Node 20+) + **React 18** + **Zustand**
- **TypeScript** (strict mode, no `any`)
- **pnpm workspaces** モノレポ（8パッケージ）
- **Vitest** でテスト、**tsup** + **Vite** でビルド

### パッケージ構成と依存関係
```
types (LOCKED) ← core, render, adapter-psd, adapter-abr, adapter-asl, ai, app
```
- `types`: 共有型定義（変更不可）
- `core`: ドキュメントモデル、レイヤーツリー、履歴、フィルタ
- `render`: Canvas描画、WebGLコンポジター、ビューポート
- `adapter-psd`: PSD入出力（ag-psd）
- `adapter-abr`: ブラシパーサー
- `adapter-asl`: スタイルパーサー
- `ai`: SAMセグメンテーション（onnxruntime-web）
- `app`: Electron本体（main + renderer/React UI）

### デバッグ時の検証コマンド
```bash
pnpm lint                              # ESLint（0エラー必須）
pnpm test                              # 全パッケージテスト
pnpm --filter @photoshop-app/core test # 特定パッケージのみ
pnpm build                             # 全パッケージビルド
pnpm dev                               # Electron開発モード起動
```

### バグが発生しやすい領域
- **レンダリング**: Canvas/WebGL描画、コンポジット順序、ビューポート座標変換
- **状態管理**: Zustand store の整合性、Undo/Redo の履歴管理
- **テキストレイヤー**: 編集モード切り替え、リサイズ、スタイル反映
- **PSD互換**: ag-psd のレイヤーマッピング、ブレンドモード変換
- **IPC**: Main-Renderer 間通信、Context Bridge のシリアライズ
- **AI推論**: ONNX モデルのロード、マスク生成、メモリリーク

## チーム構成

| Agent | 名称 | 役割 |
|:------|:-----|:-----|
| Leader | デバッグリーダー | 全体統括・フェーズ管理・進捗記録・最終報告 |
| A | スカウト（偵察） | バグの再現・影響範囲の特定・関連コードのマッピング |
| B | 仮説エージェント | 原因仮説の立案・優先順位付け |
| C1-C3 | 検証エージェント（並列） | 各仮説を独立に検証（Git Worktree使用） |
| D | 修正エージェント | 確定した原因に基づく修正の実装 |
| E | テストエージェント | 回帰テスト作成・実行・品質検証 |

## 共通ルール

- 各フェーズの成果物は必ず `debug-log.md` に追記する
- 推測で修正しない。仮説は検証してから修正に進む
- ドゥームループ検出: 同じ修正を3回試して失敗したら、問題のフレームを変える
- コード変更は最小限に。バグ修正に無関係なリファクタリングをしない
- **パッケージ境界を厳守**: 修正は該当パッケージ内のみ。`types` パッケージは変更不可
- **型安全**: `any` は使わない。`unknown` + 型ガードを使う
- 修正後は `pnpm lint && pnpm test` が通ることを確認

## ワークフロー

### Phase 0: バグの受付と状況確認（リーダー）

ユーザーから以下の情報を収集する（不足があれば質問）。

```
## バグ受付票
- チケットID: （既存チケットがあれば。例: PS-TEXT-008）
- バグの概要: （何が起きているか）
- 期待動作: （本来どう動くべきか）
- 再現手順: （わかっている場合）
- エラーメッセージ: （あれば全文。DevTools コンソール、Electron main プロセスログ）
- 該当パッケージ: types / core / render / adapter-psd / adapter-abr / adapter-asl / ai / app
- 環境: （OS、Node バージョン、Electron バージョン）
- 既に試したこと: （あれば）
- 緊急度: High / Medium / Low
```

### Phase 1: スカウト偵察（Agent A）

**目的**: コードを壊さず、バグの地図を作る。

Task toolでスカウトエージェントを起動する。**コード変更は一切しない。調査のみ。**

**作業内容**:
1. **バグの再現**: `pnpm dev` で起動し、再現手順を確認。DevTools コンソール/Network/Performance タブを確認
2. **影響範囲のマッピング**:
   - バグに関連するファイル一覧を特定（パッケージ横断で追跡）
   - コールチェーン/データフローを追跡（特に EventBus 経由の通信）
   - Zustand store の状態遷移を確認
   - 最近の変更（`git log --oneline -20` / `git blame`）を確認
3. **ログ注入**: 原因が不明な場合、戦略的な位置に `console.log` を追加して情報収集
   - Renderer: React コンポーネントのライフサイクル、Zustand アクション
   - Main: IPC ハンドラー、ファイル I/O
   - Render パッケージ: Canvas 描画コール、WebGL シェーダー
4. **環境確認**: `node -v`, `pnpm -v`, Electron バージョン、依存関係の整合性（`pnpm ls`）

**出力形式**:
```
## スカウトレポート

### バグ再現
- 再現性: 常に / 時々 / 特定条件下
- 再現手順: （確認済みの手順）
- エラー出力: （DevTools コンソール全文）

### 影響範囲マップ
- 該当パッケージ: core / render / app / ...
- 関連ファイル:
  - `packages/xxx/src/yyy.ts:123` — 役割の説明
  - ...
- コールチェーン: Component → Zustand action → Core API → [バグ発生箇所]
- EventBus イベント: （関連するイベント名）
- 最近の変更: （git log/blame から怪しいコミット）

### 収集した情報
- ログ出力結果: ...
- Zustand state dump: ...

### 初期所見
- 怪しい箇所: ...
- 除外できる箇所: ...
```

### Phase 2: 仮説立案（Agent B）

スカウトレポートを基に、原因仮説を立案・優先順位付けする。

**作業内容**:
1. スカウトレポートを分析
2. 2-4個の競合仮説を立てる
3. 各仮説に「検証方法」を付ける（Vitest テスト、手動再現、ログ確認等）
4. 検証コストと確率で優先順位を付ける

**出力形式**:
```
## 仮説一覧

### 仮説1: [タイトル]（確度: High/Medium/Low）
- 内容: ...
- 根拠: スカウトレポートの○○から
- 該当パッケージ: core / render / ...
- 検証方法: △△のユニットテストを書いて□□を確認する
- 検証コスト: 低/中/高
- 優先度: ★★★

### 推奨検証順序
1. 仮説X（確度高・コスト低）
2. ...
```

### Phase 3: 並列検証（Agent C1-C3 を Task tool で並列起動）

仮説の数に応じて2-3個の検証エージェントを**Task toolで並列起動**する。

**各検証エージェントの作業**:
1. 担当仮説の検証方法を実行
   - **ユニットテストで検証可能な場合**: `*.test.ts` を書いて `pnpm --filter @photoshop-app/{pkg} test` で実行
   - **手動再現が必要な場合**: `pnpm dev` でアプリを起動し、DevTools で確認
   - **描画バグの場合**: Canvas API 呼び出しのモック/スパイで描画順序を検証
2. 仮説が正しい場合 → 根本原因を特定し、修正方針を提案
3. 仮説が間違っていた場合 → 否定の根拠を記録

**ドゥームループ防止ルール**:
- 仮説が全て否定された場合 → Phase 1に戻り、より深いスカウトを実施
- 「まず10段落分、何が起きているか＋最善のアプローチを考えてから、次のステップに進む」

### Phase 4: 修正実装（Agent D）

確定した根本原因に基づき、最小限の修正を実装する。

**作業内容**:
1. 修正方針をユーザーに提示し、承認を得る
2. 修正を実装（最小限の変更に留める）
3. 修正前後のdiffを明示

**修正のルール**:
- バグ修正に必要な変更のみ。リファクタリングしない
- **パッケージ境界を厳守**: 他パッケージのファイルを変更しない
- **`types` パッケージは変更不可**。型変更が必要な場合はユーザーに報告
- **`any` 禁止**: `unknown` + 型ガードを使う
- 既存のコーディング規約（ESLint, Prettier）に従う
- 修正の意図をコードコメントで残す

### Phase 5: テスト・検証（Agent E）

修正が正しいことを検証し、回帰テストを作成する。

**作業内容**:
1. バグが修正されたことを再現手順で確認
2. **回帰テストを作成**: `packages/{pkg}/src/{module}.test.ts` にテストを追加
3. `pnpm lint` → 0エラー確認
4. `pnpm test` → 全パッケージPASS確認
5. `pnpm build` → ビルド成功確認
6. エッジケースの確認

**テストの書き方**:
```typescript
describe('bugfix: [バグの簡潔な説明]', () => {
  it('should [期待動作]', () => {
    // Arrange
    // Act
    // Assert
  });
});
```

### Phase 6: 最終報告と記録（リーダー）

全フェーズの成果を統合し、最終報告を作成する。

**成果物1: debug-log.md**（プロジェクトルートに保存）

```markdown
# デバッグログ: [バグタイトル]
- 日付: YYYY-MM-DD
- チケットID: （あれば）
- 該当パッケージ: core / render / app / ...
- 緊急度: High / Medium / Low
- ステータス: 修正完了 / 一部修正 / 調査中

## バグ概要
## 根本原因
## 修正内容（変更ファイルとdiffの要約）
## 検証結果
- pnpm lint: PASS / FAIL
- pnpm test: PASS / FAIL
- pnpm build: PASS / FAIL
- 手動確認: PASS / FAIL
## 回帰テスト
- テストファイル: `packages/xxx/src/yyy.test.ts`
## 学んだこと
```

**成果物2: ユーザーへの報告**

```
## バグ修正レポート
### 結論
### 根本原因
### 変更点（パッケージ別）
### テスト結果（lint / test / build）
### 残課題
```

## フェーズ間の判断ルール

| 状況 | アクション |
|:-----|:---------|
| Phase 1で原因が明白 | Phase 2-3をスキップし、Phase 4へ |
| Phase 3で全仮説が否定 | Phase 1に戻り深堀りスカウト |
| Phase 4の修正でテスト失敗 | Phase 2に戻り仮説を再検討 |
| 3回同じ修正が失敗 | 問題のフレームを変えて再アプローチ |
| `types` パッケージの変更が必要 | ユーザーに報告し、別チケットとして対応を提案 |
| 複数パッケージに跨る修正 | ユーザーに修正範囲を報告し承認を得る |
